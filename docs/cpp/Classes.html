

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Classes &mdash; Coding Art</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Coding Art" href="../index.html"/>
        <link rel="up" title="C++" href="index.html"/>
        <link rel="next" title="Functions" href="Functions.html"/>
        <link rel="prev" title="Scoping" href="Scoping.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> CodingArt
          

          
          </a>

          
            
            
              <div class="version">
                0.0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../c/index.html">C</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">C++</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Background.html">Background</a></li>
<li class="toctree-l2"><a class="reference internal" href="HeaderFile.html">Header Files</a></li>
<li class="toctree-l2"><a class="reference internal" href="Scoping.html">Scoping</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">Classes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#constructors">Constructors</a></li>
<li class="toctree-l3"><a class="reference internal" href="#implicit-conversions">Implicit Conversions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#copyable-and-movable-types">Copyable and Movable Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#structs-vs-classes">Structs VS. Classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#inheritance">Inheritance</a></li>
<li class="toctree-l3"><a class="reference internal" href="#multiple-inheritance">Multiple Inheritance</a></li>
<li class="toctree-l3"><a class="reference internal" href="#interfaces">Interfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="#operator-overloading">Operator Overloading</a></li>
<li class="toctree-l3"><a class="reference internal" href="#access-control">Access Control</a></li>
<li class="toctree-l3"><a class="reference internal" href="#declaration-order">Declaration Order</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Functions.html">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="CPPFeatures.html">C++ Features</a></li>
<li class="toctree-l2"><a class="reference internal" href="Naming.html">Naming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Comments.html">Comments</a></li>
<li class="toctree-l2"><a class="reference internal" href="Formatting.html">Formatting</a></li>
<li class="toctree-l2"><a class="reference internal" href="Exceptions.html">Exceptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="End.html">Ending</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../lua/index.html">Lua</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xml/index.html">XML</a></li>
<li class="toctree-l1"><a class="reference internal" href="../json/index.html">JSON</a></li>
<li class="toctree-l1"><a class="reference internal" href="../shell/index.html">Shell</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python/index.html">Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../git/index.html">Git Style</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/index.html">Appendix</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">CodingArt</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">C++</a> &raquo;</li>
      
    <li>Classes</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="classes">
<h1>Classes</h1>
<p>Classes are the fundamental unit of code in C++.</p>
<div class="section" id="constructors">
<span id="cpp-constructors"></span><h2>Constructors</h2>
<p>It is possible to perform arbitrary initialization in the body of the constructor.</p>
<ul class="simple">
<li>Avoid virtual method calls in constructors.</li>
<li>Avoid initialization that can fail if you can&#8217;t signal an error.</li>
<li>No need to worry about whether the class has been initialized or not.</li>
<li>Objects that are fully initialized by constructor call can be const and may also be easier to use
with standard containers or algorithms.</li>
</ul>
</div>
<div class="section" id="implicit-conversions">
<span id="cpp-implicit-conversions"></span><h2>Implicit Conversions</h2>
<p>Do not define implicit conversions. Use the <code class="docutils literal"><span class="pre">explicit</span></code> keyword for conversion operators and
single-argument constructors.</p>
<p>Implicit conversions allow an object of one type (called the source type) to be used where a
different type (called the destination type) is expected, e.g. when passing an <code class="docutils literal"><span class="pre">int</span></code> argument to a
function that takes a <code class="docutils literal"><span class="pre">double</span></code> parameter.</p>
<p>In addition to the implicit conversions defined by the language, users can define their own, by
adding appropriate members to the class definition of the source or destination type.
An implicit conversion in the source type is defined by a type conversion operator named after the
destination type (e.g. operator bool()).
An implicit conversion in the destination type is defined by a constructor that can take the source
type as its only argument (or only argument with no default value).</p>
<p>The <code class="docutils literal"><span class="pre">explicit</span></code> keyword can be applied to a constructor or (since C++11) a conversion operator, to
ensure that it can only be used when the destination type is explicit at the point of use, e.g. with
a <code class="docutils literal"><span class="pre">cast</span></code>. This applies not only to implicit conversions, but to C++11&#8217;s list initialization syntax.</p>
<ul class="simple">
<li>Implicit conversions can make a type more usable and expressive by eliminating the need to
explicitly name a type when it&#8217;s obvious.</li>
<li>Implicit conversions can be a simpler alternative to overloading.</li>
<li>List initialization syntax is a concise and expressive way of initializing objects.</li>
<li>Implicit conversions can hide type-mismatch bugs, where the destination type does not match the
user&#8217;s expectation, or the user is unaware that any conversion will take place.</li>
<li>Implicit conversions can make code harder to read, particularly in the presence of overloading,
by making it less obvious what code is actually getting called.</li>
<li>Constructors that take a single argument may accidentally be usable as implicit type conversions,
even if they are not intended to do so.</li>
<li>When a single-argument constructor is not marked explicit, there&#8217;s no reliable way to tell whether
it&#8217;s intended to define an implicit conversion, or the author simply forgot to mark it.</li>
<li>It&#8217;s not always clear which type should provide the conversion, and if they both do, the code
becomes ambiguous.</li>
<li>List initialization can suffer from the same problems if the destination type is implicit,
particularly if the list has only a single element.</li>
</ul>
<p>Type conversion operators, and constructors that are callable with a single argument, must be marked
<code class="docutils literal"><span class="pre">explicit</span></code> in the class definition. As an exception, copy and move constructors should not be
explicit, since they do not perform type conversion. Implicit conversions can sometimes be necessary
and appropriate for types that are designed to transparently wrap other types. In that case, contact
your project leads to request a waiver of this rule.</p>
<p>Constructors that cannot be called with a single argument should usually omit explicit. Constructors
that take a single <code class="docutils literal"><span class="pre">std::initializer_list</span></code> parameter should also omit explicit, in order to
support copy-initialization (e.g. <code class="docutils literal"><span class="pre">MyType</span> <span class="pre">m</span> <span class="pre">=</span> <span class="pre">{1,</span> <span class="pre">2};</span></code>).</p>
</div>
<div class="section" id="copyable-and-movable-types">
<span id="cpp-copyable-and-movable-types"></span><h2>Copyable and Movable Types</h2>
<p>Support copying and/or moving if these operations are clear and meaningful for your type. Otherwise,
disable the implicitly generated special functions that perform copies and moves.</p>
<p>A <strong>copyable</strong> type allows its objects to be initialized or assigned from any other object of the
same type, without changing the value of the source. For user-defined types, the copy behavior is
defined by the copy constructor and the copy-assignment operator. <code class="docutils literal"><span class="pre">string</span></code> is an example of a
copyable type.</p>
<p>A <strong>movable</strong> type is one that can be initialized and assigned from temporaries (all copyable types
are therefore movable). <code class="docutils literal"><span class="pre">std::unique_ptr&lt;int&gt;</span></code> is an example of a movable but not copyable type.
For user-defined types, the move behavior is defined by the move constructor and the move-assignment
operator.</p>
<p>The copy/move constructors can be implicitly invoked by the compiler in some situations,
e.g. when passing objects by value.</p>
<p>Objects of copyable and movable types can be passed and returned by value, which makes APIs simpler,
safer, and more general. Unlike when passing objects by pointer or reference, there&#8217;s no risk of
confusion over ownership, lifetime, mutability, and similar issues, and no need to specify them in
the contract. It also prevents non-local interactions between the client and the implementation,
which makes them easier to understand, maintain, and optimize by the compiler. Further, such objects
can be used with generic APIs that require pass-by-value, such as most containers, and they allow
for additional flexibility in e.g., type composition.</p>
<p>Copy/move constructors and assignment operators are usually easier to define correctly than
alternatives like <code class="docutils literal"><span class="pre">Clone()</span></code>, <code class="docutils literal"><span class="pre">CopyFrom()</span></code> or <code class="docutils literal"><span class="pre">Swap()</span></code>, because they can be generated by the
compiler, either implicitly or with <code class="docutils literal"><span class="pre">=</span></code> default. They are concise, and ensure that all data members
are copied. Copy and move constructors are also generally more efficient, because they don&#8217;t require
heap allocation or separate initialization and assignment steps, and they&#8217;re eligible for
optimizations such as copy elision.</p>
<p>Move operations allow the implicit and efficient transfer of resources out of rvalue objects. This
allows a plainer coding style in some cases.</p>
<p>Some types do not need to be copyable, and providing copy operations for such types can be
confusing, nonsensical, or outright incorrect. Types representing singleton objects (Registerer),
objects tied to a specific scope (Cleanup), or closely coupled to object identity (Mutex) cannot be
copied meaningfully. Copy operations for base class types that are to be used polymorphically are
hazardous, because use of them can lead to object slicing. Defaulted or carelessly-implemented copy
operations can be incorrect, and the resulting bugs can be confusing and difficult to diagnose.</p>
<p>Copy constructors are invoked implicitly, which makes the invocation easy to miss. This may cause
confusion for programmers used to languages where pass-by-reference is conventional or mandatory.
It may also encourage excessive copying, which can cause performance problems.</p>
<p>Provide the copy and move operations if their meaning is clear to a casual user and the
copying/moving does not incur unexpected costs. If you define a copy or move constructor, define
the corresponding assignment operator, and vice-versa. If your type is copyable, do not define move
operations unless they are significantly more efficient than the corresponding copy operations. If
your type is not copyable, but the correctness of a move is obvious to users of the type, you may
make the type move-only by defining both of the move operations.</p>
<p>If your type provides copy operations, it is recommended that you design your class so that the
default implementation of those operations is correct. Remember to review the correctness of any
defaulted operations as you would any other code, and to document that your class is copyable and/or
cheaply movable if that&#8217;s an API guarantee.</p>
</div>
<div class="section" id="structs-vs-classes">
<span id="cpp-structs-vs-classes"></span><h2>Structs VS. Classes</h2>
<p>Use a <code class="docutils literal"><span class="pre">struct</span></code> only for passive objects that carry data, and everything else is a <code class="docutils literal"><span class="pre">class</span></code>.</p>
<p>The <code class="docutils literal"><span class="pre">struct</span></code> and <code class="docutils literal"><span class="pre">class</span></code> keywords behave almost identically in C++. We add our own semantic
meanings to each keyword, so you should use the appropriate keyword for the data-type you&#8217;re defining.</p>
<p><code class="docutils literal"><span class="pre">structs</span></code> should be used for passive objects that carry data, and may have associated constants,
but lack any functionality other than access/setting the data members. The accessing/setting of
fields is done by directly accessing the fields rather than through method invocations. Methods
should not provide behavior but should only be used to set up the data members, e.g., constructor,
destructor, Initialize(), Reset(), Validate().</p>
<p>If more functionality is required, a <code class="docutils literal"><span class="pre">class</span></code> is more appropriate. If in doubt, make it a <code class="docutils literal"><span class="pre">class</span></code>.</p>
<p>For consistency with STL, you can use <code class="docutils literal"><span class="pre">struct</span></code> instead of <code class="docutils literal"><span class="pre">class</span></code> for functors and traits.</p>
<p>Note that member variables in <code class="docutils literal"><span class="pre">struct</span></code> and <code class="docutils literal"><span class="pre">class</span></code> have different naming rules. Data members are
all lowercase, with underscores between words, can have digit number if necessary. Data members of
<code class="docutils literal"><span class="pre">class</span></code> leading with <code class="docutils literal"><span class="pre">x_</span></code>, while data members of <code class="docutils literal"><span class="pre">struct</span></code> have perfix of <code class="docutils literal"><span class="pre">m_</span></code>, e.g.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// here we use suffix of _st, because in C++ we can omit struct</span>
<span class="c1">// directly use the struct name, not like C way.</span>
<span class="k">struct</span> <span class="n">a_struct_type_st</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">m_age</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ThisIsClass</span>
<span class="p">{</span>
    <span class="n">string</span> <span class="n">x_name</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="inheritance">
<span id="cpp-inheritance"></span><h2>Inheritance</h2>
<p>Composition is often more appropriate than inheritance. When using inheritance, make it public.</p>
</div>
<div class="section" id="multiple-inheritance">
<span id="cpp-multiple-inheritance"></span><h2>Multiple Inheritance</h2>
<p>Only very rarely is multiple implementation inheritance actually useful.
We allow multiple inheritance only when at most one of the base classes has an implementation;
all other base classes must be pure interface classes tagged with the Interface suffix.</p>
</div>
<div class="section" id="interfaces">
<span id="cpp-interfaces"></span><h2>Interfaces</h2>
<p>Classes that satisfy certain conditions are allowed, but not required, to end with an Interface
suffix.</p>
</div>
<div class="section" id="operator-overloading">
<span id="cpp-operator-overloading"></span><h2>Operator Overloading</h2>
<p>Overload operators judiciously. Do not create user-defined literals.</p>
</div>
<div class="section" id="access-control">
<span id="cpp-access-control"></span><h2>Access Control</h2>
<p>Make data members private, unless they are <code class="docutils literal"><span class="pre">static</span> <span class="pre">const</span></code>.</p>
</div>
<div class="section" id="declaration-order">
<span id="cpp-declaration-order"></span><h2>Declaration Order</h2>
<p>Group similar declarations together, placing <code class="docutils literal"><span class="pre">public</span></code> parts earlier.</p>
<p>A class definition should usually start with a <code class="docutils literal"><span class="pre">public</span></code> section, followed by <code class="docutils literal"><span class="pre">protected</span></code>, then
<code class="docutils literal"><span class="pre">private</span></code>. Omit sections that would be empty.</p>
<p>Within each section, generally prefer grouping similar kinds of declarations together, and generally
prefer the following order:</p>
<blockquote>
<div><ul class="simple">
<li>types (including <code class="docutils literal"><span class="pre">typedef</span></code>, <code class="docutils literal"><span class="pre">using</span></code>, and nested <code class="docutils literal"><span class="pre">struct</span></code> and <code class="docutils literal"><span class="pre">class</span></code>)</li>
<li>constants</li>
<li>factory functions</li>
<li>constructors</li>
<li>assignment operators</li>
<li>destructor</li>
<li>all other methods</li>
<li>data members</li>
</ul>
</div></blockquote>
<p>Do not put large method definitions <code class="docutils literal"><span class="pre">inline</span></code> in the class definition. Usually, only trivial or
performance-critical, and very short, methods may be defined <code class="docutils literal"><span class="pre">inline</span></code>.</p>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Functions.html" class="btn btn-neutral float-right" title="Functions" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Scoping.html" class="btn btn-neutral" title="Scoping" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, gkvim.
      Last updated on May 21, 2017.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>